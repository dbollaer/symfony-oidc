<?php

namespace Drenso\OidcBundle\Security;

use Drenso\OidcBundle\Enum\OidcTokenType;
use Drenso\OidcBundle\Exception\OidcException;
use Drenso\OidcBundle\Model\OidcTokens;
use Drenso\OidcBundle\Model\OidcUserData;
use Drenso\OidcBundle\OidcClientInterface;
use Drenso\OidcBundle\OidcJwtHelper;
use Drenso\OidcBundle\Security\Exception\InvalidJwtTokenException;
use Drenso\OidcBundle\Security\Exception\OidcAuthenticationException;
use Drenso\OidcBundle\Security\Token\OidcToken;
use Drenso\OidcBundle\Security\UserProvider\OidcUserProviderInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\UserNotFoundException;
use Symfony\Component\Security\Http\Authenticator\AuthenticatorInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;

/**
 * Authenticator that only validates access tokens generated by token exchange (API access tokens).
 * Does not support OIDC login flow.
 */
class OidcTokenExchangeAuthenticator implements AuthenticatorInterface
{
  /**
   * @param OidcUserProviderInterface<\Symfony\Component\Security\Core\User\UserInterface> $oidcUserProvider
   * @param bool $resourceProviderMode If true, uses JWT validation (resource provider mode).
   *                                   If false, uses introspection (token exchange mode).
   */
  public function __construct(
    private readonly OidcClientInterface $oidcClient,
    private readonly OidcJwtHelper $jwtHelper,
    private readonly OidcUserProviderInterface $oidcUserProvider,
    private readonly string $userIdentifierProperty = 'sub',
    private readonly bool $resourceProviderMode = true,
  ) {
  }

  /** Decide if this authenticator should be used for the request. */
  public function supports(Request $request): ?bool
  {
    $authHeader = $request->headers->get('Authorization');

    return is_string($authHeader) && str_starts_with(trim($authHeader), 'Bearer ');
  }

  /** @throws Exception\InvalidJwtTokenException */
  public function authenticate(Request $request): Passport
  {
    try {
      // Extract bearer token from Authorization header
      $authHeader = $request->headers->get('Authorization');
      if (!is_string($authHeader) || !str_starts_with(trim($authHeader), 'Bearer ')) {
        throw new AuthenticationException('No Bearer token found in Authorization header.');
      }
      $accessToken = trim(substr($authHeader, 7));
      if ($accessToken === '') {
        throw new AuthenticationException('Bearer token is empty.');
      }

      // Create OidcTokens object with the access token
      // Note: OidcTokens requires both access_token and id_token, so we use the same token for both
      // This is a workaround since resource server tokens typically only have an access token
      $tokens = new OidcTokens((object)[
        'access_token' => $accessToken,
        'id_token'     => $accessToken,
      ]);

      $userData = null;
      $userIdentifier = null;

      if ($this->resourceProviderMode) {
        // Resource Provider Mode: Try JWT validation first (local, no network call)
        // OidcJwtHelper::verifyAccessToken() gracefully handles opaque tokens internally
        try {
          // First, try to parse as JWT to check if it's a JWT token
          $parsedToken = OidcJwtHelper::parseToken($accessToken);

          // Validate JWT signature, issuer, and expiration
          // This will throw OidcAuthenticationException if JWT validation fails
          // but gracefully handles opaque tokens (catches InvalidJwtTokenException internally)
          $issuer = $this->oidcClient->getIssuer();
          $jwksUri = $this->oidcClient->getJwksUri();
          $this->jwtHelper->verifyAccessToken($issuer, $jwksUri, $tokens, false);

          // If we get here, JWT validation succeeded - extract user data from claims
          $claims = $parsedToken->claims()->all();
          $userData = new OidcUserData($claims);

          // Extract user identifier from JWT claims
          $userIdentifier = $parsedToken->claims()->get($this->userIdentifierProperty);
          if (!is_string($userIdentifier) || $userIdentifier === '') {
            // Try to get from claims array directly
            $userIdentifier = $claims[$this->userIdentifierProperty] ?? null;
            if ($userIdentifier !== null) {
              $userIdentifier = (string)$userIdentifier;
            }
          }
        } catch (InvalidJwtTokenException) {
          // Token is not a JWT (opaque token) - fall back to introspection
          // This is expected for opaque tokens and handled gracefully
        }
        // Note: OidcAuthenticationException from verifyAccessToken() means JWT validation failed
        // (invalid signature, expired, etc.) - we let it bubble up as it indicates an invalid token

        // Fallback to introspection if JWT validation failed or user data not extracted
        if ($userData === null || $userIdentifier === null || $userIdentifier === '') {
          $introspectionData = $this->oidcClient->introspect($tokens, OidcTokenType::ACCESS);

          if (!$introspectionData->isActive()) {
            throw new AuthenticationException('Token is not active');
          }

          // Get user information from introspection data
          $userData = new OidcUserData($introspectionData->getIntrospectionDataArray());
          $userIdentifier = $introspectionData->getSub();
        }
      } else {
        // Token Exchange Mode: Use introspection only (original behavior)
        $introspectionData = $this->oidcClient->introspect($tokens, OidcTokenType::ACCESS);

        if (!$introspectionData->isActive()) {
          throw new AuthenticationException('Token is not active');
        }

        // Get user information from introspection data
        $userData = new OidcUserData($introspectionData->getIntrospectionDataArray());
        $userIdentifier = $introspectionData->getSub();
      }

      // Ensure the user exists
      if (!$userIdentifier || $userIdentifier === '') {
        throw new UserNotFoundException(
          sprintf('User identifier property (%s) yielded empty user identifier', $this->userIdentifierProperty));
      }
      $this->oidcUserProvider->ensureUserExists($userIdentifier, $userData, $tokens);

      // Create the passport with user data for RRN extraction
      $passport = new SelfValidatingPassport(new UserBadge(
        $userIdentifier,
        fn (string $userIdentifier) => $this->oidcUserProvider->loadOidcUser($userIdentifier),
      ));
      $passport->setAttribute(OidcToken::AUTH_DATA_ATTR, $tokens);
      $passport->setAttribute(OidcToken::USER_DATA_ATTR, $userData);

      return $passport;
    } catch (OidcException $e) {
      throw new OidcAuthenticationException('OIDC authentication failed', $e);
    }
  }

  /** Create an authenticated token for the given user. */
  public function createToken(Passport $passport, string $firewallName): TokenInterface
  {
    // Create a token for the authenticated user
    return new OidcToken($passport, $firewallName);
  }

  /** Called when authentication executed and was successful. */
  public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
  {
    // On success, let the request continue (API style)
    return null;
  }

  /** Called when authentication executed, but failed. */
  public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
  {
    // Return a 401 JSON response with the error message
    return new \Symfony\Component\HttpFoundation\JsonResponse([
      'message' => strtr($exception->getMessageKey(), $exception->getMessageData()),
    ], Response::HTTP_UNAUTHORIZED);
  }
}
